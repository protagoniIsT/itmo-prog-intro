# Тесты к курсу «Введение в программирование»

[Условия домашних заданий](https://www.kgeorgiy.info/courses/prog-intro/homeworks.html)


## Домашнее задание 9. Markdown to HTML

Модификации
 * *Базовая*
    * [Исходный код тестов](java/md2html/Md2HtmlTester.java)
    * [Откомпилированные тесты](artifacts/Md2HtmlTest.jar)
        * Аргументы командной строки: модификации


## Домашнее задание 7. Разметка

Модификации
 * *Base*
    * Исходный код тестов:
        * [MarkupTester.java](java/markup/MarkupTester.java)
        * [MarkupTest.java](java/markup/MarkupTest.java)
        * Аргументы командной строки: модификации
    * Откомпилированных тестов не существуют,
      так как они зависят от вашего кода
 * *BBCode* (32-35)
    * Дополнительно реализуйте метод `toBBCode`, генерирующий [BBCode](https://en.wikipedia.org/wiki/BBCode)-разметку:
      * выделеный текст окружается тегом `[i]`;
      * сильно выделеный текст окружается тегом `[b]`;
      * зачеркнутый текст окружается тегом `[s]`.
 * *BBCodeList* (36-39)
    * Сделайте модификацию *BBCode*
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, тег `[list=1]`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, тег `[list]`): последовательность элементов
      * Элементов списка (класс `ListItem`, открывающий тег `[*]`): последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
    * [Исходный код тестов](java/markup/MarkupListTest.java)


## Домашнее задание 6. Подсчет слов++

Модификации
 * *Base*
    * Класс должен иметь имя `Wspp`
    * Исходный код тестов:
        [WsppTest.java](java/wspp/WsppTest.java),
        [WsppTester.java](java/wspp/WsppTester.java)
    * Откомпилированные тесты: [WsppTest.jar](artifacts/WsppTest.jar)
        * Аргументы командной строки: модификации
 * *Position* (32, 33)
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`,
      где номер в строке считается с конца
    * Класс должен иметь имя `WsppPosition`
 * *SortedPosition* (34, 35)
    * В выходном файле слова должны быть упорядочены
      в лексикографическом порядке
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`,
      где номер в строке считается с конца
    * Класс должен иметь имя `WsppSortedPosition`
 * *SortedFirst* (36, 37)
    * В выходном файле слова должны быть упорядочены
      в лексикографическом порядке
    * Вместо номеров вхождений во всем файле надо указывать
      только первое вхождение в каждой строке
    * Класс должен иметь имя `WsppSortedFirst`
 * *SortedRFirst* (38, 39)
    * В выходном файле слова должны быть упорядочены
      в лексикографическом порядке перевёрнутых слов
    * Вместо номеров вхождений во всем файле надо указывать
      только первое вхождение в каждой строке
    * Класс должен иметь имя `WsppSortedRFirst`


## Домашнее задание 5. Свой сканнер

Модификации
 * *Base*
    * Исходный код тестов: [FastReverseTest.java](java/reverse/FastReverseTest.java)
    * Откомпилированные тесты: [FastReverseTest.jar](artifacts/FastReverseTest.jar)
        * Аргументы командной строки: модификации
 * *MinRAbc* (32, 33)
    * Вместо каждого числа выведите минимум из чисел, предшествующих
      ему в строки и его самого
    * Во вводе и выводе десятичные числа пишутся буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseMinRAbc`
 * *MinСAbc* (34, 35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите минимум из чисел,
      находящихся в его столбце в предыдущих строках, и его самого
    * Во вводе и выводе десятичные числа пишутся буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseMinCAbc`
 * *SumHexAbc* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в прямоугольнике верхний левый угол матрицы — текущее число
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`
    * Десятичные числа записаны буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * В выходе должны быть десятичные числа, записаные буквами
    * Класс должен иметь имя `ReverseSumHexAbc`
 * *SumHexDecAbc* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в прямоугольнике верхний левый угол матрицы — текущее число
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`
    * Десятичные числа могут быть записаны буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * В выходе должны быть десятичные числа, записаные буквами
    * Класс должен иметь имя `ReverseSumHexDecAbc`


## Домашнее задание 4. Подсчет слов

Модификации
 * *Base*
    * Класс должен иметь имя `WordStatInput`
    * Исходный код тестов:
        [WordStatTest.java](java/wordStat/WordStatTest.java),
        [WordStatTester.java](java/wordStat/WordStatTester.java),
        [WordStatChecker.java](java/wordStat/WordStatChecker.java)
    * Откомпилированные тесты: [WordStatTest.jar](artifacts/WordStatTest.jar)
        * Аргументы командной строки: модификации
 * *CountPrefixL* (32, 33)
    * Выходной файл должен содержать все различные префиксы длины 3
      слов, встречающихся во входном файле, упорядоченые
      по возрастанию числа вхождений, а при равном числе вхождений –
      по порядку первого вхождения во входном файле.
      Слова длины меньшей 3 игнорируются.
    * Класс должен иметь имя `WordStatCountPrefixL`
 * *Count* (34, 35)
    * В выходном файле слова должны быть упорядочены
      по возрастанию числа вхождений, а при равном числе вхождений –
      по порядку первого вхождения во входном файле.
    * Класс должен иметь имя `WordStatCount`
 * *CountMiddleL* (36, 37)
    * Назовём _серединой слова_ подстроку, полученую удалением
      первых и последних 2 символов слова.
      Слова длины меньшей 5 игнорируются.
    * Выходной файл должен содержать все различные середины слов
      слов, встречающихся во входном файле,
      упорядоченые по возрастанию числа вхождений, а при равном числе вхождений –
      по порядку первого вхождения во входном файле.
    * Класс должен иметь имя `WordStatCountMiddleL`
 * *CountAffixL* (38, 39)
    * Назовём _аффиксом слова_ его префикс и суффикс длины 2.
      Слова длины меньшей 2 игнорируются.
    * Выходной файл должен содержать все различные 
      аффиксы слов, встречающихся во входном файле,
      упорядоченые по возрастанию числа вхождений, а при равном числе вхождений –
      по порядку первого вхождения во входном файле.
    * Класс должен иметь имя `WordStatCountAffixL`
 * *FastSort* (36 - 39)
    * Пусть _n_ – число слов во входном файле,
      тогда программа должна работать за O(_n_ log _n_).




## Домашнее задание 3. Реверс

Модификации
 * *Base*
    * Исходный код тестов:
        [ReverseTest.java](java/reverse/ReverseTest.java),
        [ReverseTester.java](java/reverse/ReverseTester.java)
    * Откомпилированные тесты: [ReverseTest.jar](artifacts/ReverseTest.jar)
        * Аргументы командной строки: модификации
 * *MinR* (32, 33)
    * Вместо каждого числа выведите минимум из чисел, предшествующих
      ему в строки и его самого
    * Класс должен иметь имя `ReverseMinR`
 * *MinС* (34, 35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите минимум из чисел,
      находящихся в его столбце в предыдущих строках, и его самого
    * Класс должен иметь имя `ReverseMinC`
 * *SumHex* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в прямоугольнике верхний левый угол матрицы — текущее число.
    * Во вводе и выводе используются числа в шестнадцатеричной системе счисления.
    * Класс должен иметь имя `ReverseSumHex`.
 * *SumHexDec* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в прямоугольнике верхний левый угол матрицы — текущее число.
    * На вход подаются десятичные и шестнадцатеричные числа.
    * Шестнадцатеричные числа имеют префикс `0x`.
    * Класс должен иметь имя `ReverseSumHexDec`.
 * *Memory* (36-39)
    * Пусть _M_ – объём памяти, необходимый для сохранения ввода
      в двумерном массиве `int` минимального размера.
      Ваша программа должна использовать не более 4_M_ + 1024 байт памяти.
    * Накладные расходы на запуск вашей программы JVM не учитываются.


## Домашнее задание 2. Сумма чисел

Модификации
 * *Double* (32, 33)
    * Входные данные являются 64-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumDouble`
 * *DoubleSpace* (34, 35)
    * Входные данные являются 64-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumDoubleSpace`
    * Числа разделяются [пробелами-разделителями](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#SPACE_SEPARATOR)
 * *LongSpace* (36, 37)
    * Входные данные являются 64-битными целыми числами
    * Класс должен иметь имя `SumLongSpace`
    * Числа разделяются [пробелами-разделителями](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#SPACE_SEPARATOR)
 * *BigIntegerSpace* (38, 39)
    * Входные данные помещаются в тип [BigInteger](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.html)
    * Класс должен иметь имя `SumBigIntegerSpace`
    * Числа разделяются [пробелами-разделителями](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#SPACE_SEPARATOR)


Для того, чтобы протестировать программу:

 1. Скачайте откомпилированные тесты ([SumTest.jar](artifacts/SumTest.jar))
 1. Откомпилируйте `Sum.java`
 1. Проверьте, что создался `Sum.class`
 1. В каталоге, в котором находится `Sum.class`, выполните команду
    ```
       java -ea -jar <путь к SumTest.jar> Base
    ```
    * Например, если `SumTest.jar` находится в текущем каталоге, выполните команду
    ```
        java -ea -jar SumTest.jar Base
    ```
 1. Для ускорени отладки рекомендуется сделать скрипт, выполняющий шаги 2−4.

Исходный код тестов:

* [SumTest.java](java/sum/SumTest.java)
* [SumTester.java](java/sum/SumTester.java)
* [Базовые классы](java/base/)


## Домашнее задание 1. Запусти меня!

Модификации
  * *RunMe*
    1. Скачайте исходный код ([RunMe.java](java/RunMe.java))
    1. Создайте скрипт, компилирующий и запускающий `RunMe` из командной строки
       с выданными вам аргументами командной строки
    1. Следуйте выведенной инструкции

Рекомендации по выполнению модификации

1. Проверьте версию Java:
    1. Запустите `javac --version` и проверьте, что версия
       находится в диапазоне 17..20 (в крайнем случае, 11..21).
    1. Запустите `java --version` и проверьте, что версия,
       такая же как и у `javac`.
1. Скачайте [RunMe.java](java/RunMe.java)
1. Откомпилируйте `RunMe.java`:
    1. Запустите `javac RunMe.java`
    1. Убедитесь, что компиляция завершилась без ошибок
    1. Проверьте, что появился `RunMe.class`
1. Запустите `RunMe`:
    1. Запустите `java RunMe [шесть] [слов] [пароля] [пришедшего] [на] [email]`
    1. При правильном исполнении вы должны получить ссылку.
       Если получено сообщение об ошибке — исправьте её и запустите повторно
    1. Зайдите по полученной ссылке и убедитесь, что она правильная
1. Напишите и протестируйте скрипт:
    1. Напишите скрипт, включающий команды компиляции и запуска.
       Если вы не умеете писать скрипты, воспользуйтесь одной из инструкций:
       [Windows](https://www.windowscentral.com/how-create-and-run-batch-file-windows-10),
       [Linux](https://linuxhint.com/write_simple_bash_script/),
       [macOS](https://phoenixnap.com/kb/write-bash-script)
    1. Запустите и проверьте, что вы получили ту же ссылку, что и в предыдущем пункте
    1. Сдайте скрипт преподавателю
1. Вы можете получить больше плюсиков, модифицируя код `RunMe.java`

============================================================================================================================================

Этот репозиторий будет склонирован для каждого студента и доступен по адресу
`https://www.kgeorgiy.info/git-students/year2023/<USER>/prog-intro`,
где `<USER>` — имя пользователя в PCMS (пароль так же используется из PCMS).

Для сдачи домашних заданий
 * Клонируйте ваш личный репозиторий
    * `git clone https://www.kgeorgiy.info/git-students/year2023/<USER>/prog-intro`
    * У личных репозиториев __нет__ web-интерфейса, используйте инструменты командной строки.
 * Добавьте ссылку на исходный репозиторий
    * `git remote add source https://www.kgeorgiy.info/git/geo/prog-intro-2023-solutions`
    * Теперь можно будет забирать обновления командой `git pull source master`.
 * Добавляйте _только_ исходные файлы решений
    * Сохраняйте текущую структуру каталогов и имена файлов.
    * Не добавляйте исходный код тестов, `.class`-файлы и файлы проектов.
    * Не добавляйте тесты и другой код из репозитория с тестами.
    * Если структура репозитория не соответствует исходной, преподаватель не будет проверять решение.
    * Вы можете редактировать `.gitignore` как вам удобно.
 * Перед отправкой решения на проверку
    * Проверьте, что _все_ исходники компилируются (в том числе, тех ДЗ, которые вы не сдаёте).
    * Проверьте, что тесты сдаваемого ДЗ проходят.
    * Закоммитьте все изменения в `master`.
    * Запуште все изменения.
    * Запросите проверку решения, заполнив форму.
 * После проверки преподаватель либо укажет найденные недостатки в `NOTES.md`,
   либо укажет их в виде комментариев в исходном коде, пометив их как `:NOTE:`.

 
